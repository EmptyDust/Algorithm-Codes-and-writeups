{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"dsu": {
		"scope": "c++,cpp",
		"prefix": "dsu",
		"body": [
			"struct dsu {",
			"    std::vector<int> d;",
			"    dsu(int n) { d.resize(n); iota(d.begin(), d.end(), 0); }",
			"    int get_root(int x) { return d[x] = (x == d[x] ? x : get_root(d[x])); };",
			"    bool merge(int u, int v) {",
			"        if (get_root(u) != get_root(v)) {",
			"            d[get_root(u)] = get_root(v);",
			"            return true;",
			"        }",
			"        else return false;",
			"    }",
			"};"
		],
		"description": "dsu."
	},
	"fenwick": {
		"scope": "cpp",
		"prefix": "fenwick",
		"body": [
			"template<typename T>",
			"struct Fenwick {",
			"    int n;",
			"    std::vector<T> a;",
			"",
			"    Fenwick(int n_ = 0) {",
			"        init(n_);",
			"    }",
			"",
			"    void init(int n_) {",
			"        n = n_;",
			"        a.assign(n + 5, T{});",
			"    }",
			"",
			"    void add(int x, const T& v) {",
			"        for (int i = x; i <= n; i += i & -i) {",
			"            a[i] = a[i] + v;",
			"        }",
			"    }",
			"",
			"    T sum(int x) {",
			"        T ans{};",
			"        for (int i = x; i > 0; i -= i & -i) {",
			"            ans = ans + a[i];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    T rangeSum(int l, int r) {",
			"        return sum(r) - sum(l);",
			"    }",
			"",
			"    int select(const T& k) {",
			"        int x = 0;",
			"        T cur{};",
			"        for (int i = 1 << std::__lg(n); i; i /= 2) {",
			"            if (x + i <= n && cur + a[x + i] <= k) {",
			"                x += i;",
			"                cur = cur + a[x];",
			"            }",
			"        }",
			"        return x;",
			"    }",
			"};"
		],
		"description": "fenwick"
	},
	"twosat": {
		"prefix": "twosat",
		"body": [
			"struct TwoSat {",
			"    int n;",
			"    std::vector<std::vector<int>> e;",
			"    std::vector<bool> ans;",
			"    TwoSat(int n) : n(n), e(2 * n), ans(n) {}",
			"    void addEdge(int u, bool f, int v, bool g) {",
			"        e[2 * u + f].push_back(2 * v + g);",
			"    }",
			"    void addClause(int u, bool f, int v, bool g) {",
			"        addEdge(u, !f, v, g);",
			"        addEdge(v, !g, u, f);",
			"    }",
			"    void notClause(int u, bool f, int v, bool g) {",
			"        addClause(u, !f, v, !g);",
			"    }",
			"    bool satisfiable() {",
			"        std::vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);",
			"        std::vector<int> stk;",
			"        int now = 0, cnt = 0;",
			"        std::function<void(int)> tarjan = [&](int u) {",
			"            stk.push_back(u);",
			"            dfn[u] = low[u] = now++;",
			"            for (auto v : e[u]) {",
			"                if (dfn[v] == -1) {",
			"                    tarjan(v);",
			"                    low[u] = std::min(low[u], low[v]);",
			"                }",
			"                else if (id[v] == -1) {",
			"                    low[u] = std::min(low[u], dfn[v]);",
			"                }",
			"            }",
			"            if (dfn[u] == low[u]) {",
			"                int v;",
			"                do {",
			"                    v = stk.back();",
			"                    stk.pop_back();",
			"                    id[v] = cnt;",
			"                } while (v != u);",
			"                ++cnt;",
			"            }",
			"            };",
			"        for (int i = 0; i < 2 * n; ++i) if (dfn[i] == -1) tarjan(i);",
			"        for (int i = 0; i < n; ++i) {",
			"            if (id[2 * i] == id[2 * i + 1]) return false;",
			"            ans[i] = id[2 * i] > id[2 * i + 1];",
			"        }",
			"        return true;",
			"    }",
			"    std::vector<bool> answer() { return ans; }",
			"};"
		],
		"description": ""
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"template<class Info>",
			"struct SegmentTree {",
			"    int n;",
			"    std::vector<Info> info;",
			"    SegmentTree() : n(0) {}",
			"    SegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<class T>",
			"    SegmentTree(std::vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(std::vector(n_, v_));",
			"    }",
			"    template<class T>",
			"    void init(std::vector<T> init_) {",
			"        n = init_.size();",
			"        info.assign(4 << std::__lg(n), Info());",
			"        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r - l == 1) {",
			"                info[p] = init_[l];",
			"                return;",
			"            }",
			"            int m = (l + r) / 2;",
			"            build(2 * p, l, m);",
			"            build(2 * p + 1, m, r);",
			"            pull(p);",
			"        };",
			"        build(1, 0, n);",
			"    }",
			"    void pull(int p) {",
			"        info[p] = info[2 * p] + info[2 * p + 1];",
			"    }",
			"    void modify(int p, int l, int r, int x, const Info &v) {",
			"        if (r - l == 1) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        if (x < m) {",
			"            modify(2 * p, l, m, x, v);",
			"        } else {",
			"            modify(2 * p + 1, m, r, x, v);",
			"        }",
			"        pull(p);",
			"    }",
			"    void modify(int p, const Info &v) {",
			"        modify(1, 0, n, p, v);",
			"    }",
			"    Info rangeQuery(int p, int l, int r, int x, int y) {",
			"        if (l >= y || r <= x) {",
			"            return Info();",
			"        }",
			"        if (l >= x && r <= y) {",
			"            return info[p];",
			"        }",
			"        int m = (l + r) / 2;",
			"        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"    }",
			"    Info rangeQuery(int l, int r) {",
			"        return rangeQuery(1, 0, n, l, r);",
			"    }",
			"    template<class F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        int res = findFirst(2 * p, l, m, x, y, pred);",
			"        if (res == -1) {",
			"            res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n, l, r, pred);",
			"    }",
			"    template<class F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"        if (res == -1) {",
			"            res = findLast(2 * p, l, m, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n, l, r, pred);",
			"    }",
			"};",
			"struct Info {",
			"    int cnt = 0;",
			"    i64 sum = 0;",
			"    i64 ans = 0;",
			"};",
			"Info operator+(Info a, Info b) {",
			"    Info c;",
			"    c.cnt = a.cnt + b.cnt;",
			"    c.sum = a.sum + b.sum;",
			"    c.ans = a.ans + b.ans + a.cnt * b.sum - a.sum * b.cnt;",
			"    return c;",
			"}",
			""
		],
		"description": "SegmentTree"
	},
	"LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"template<class Info, class Tag>",
			"struct LazySegmentTree {",
			"    int n;",
			"    std::vector<Info> info;",
			"    std::vector<Tag> tag;",
			"    LazySegmentTree() : n(0) {}",
			"    LazySegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<class T>",
			"    LazySegmentTree(std::vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(std::vector(n_, v_));",
			"    }",
			"    template<class T>",
			"    void init(std::vector<T> init_) {",
			"        n = init_.size();",
			"        info.assign(4 << std::__lg(n), Info());",
			"        tag.assign(4 << std::__lg(n), Tag());",
			"        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r - l == 1) {",
			"                info[p] = init_[l];",
			"                return;",
			"            }",
			"            int m = (l + r) / 2;",
			"            build(2 * p, l, m);",
			"            build(2 * p + 1, m, r);",
			"            pull(p);",
			"        };",
			"        build(1, 0, n);",
			"    }",
			"    void pull(int p) {",
			"        info[p] = info[2 * p] + info[2 * p + 1];",
			"    }",
			"    void apply(int p, const Tag &v) {",
			"        info[p].apply(v);",
			"        tag[p].apply(v);",
			"    }",
			"    void push(int p) {",
			"        apply(2 * p, tag[p]);",
			"        apply(2 * p + 1, tag[p]);",
			"        tag[p] = Tag();",
			"    }",
			"    void modify(int p, int l, int r, int x, const Info &v) {",
			"        if (r - l == 1) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        if (x < m) {",
			"            modify(2 * p, l, m, x, v);",
			"        } else {",
			"            modify(2 * p + 1, m, r, x, v);",
			"        }",
			"        pull(p);",
			"    }",
			"    void modify(int p, const Info &v) {",
			"        modify(1, 0, n, p, v);",
			"    }",
			"    Info rangeQuery(int p, int l, int r, int x, int y) {",
			"        if (l >= y || r <= x) {",
			"            return Info();",
			"        }",
			"        if (l >= x && r <= y) {",
			"            return info[p];",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"    }",
			"    Info rangeQuery(int l, int r) {",
			"        return rangeQuery(1, 0, n, l, r);",
			"    }",
			"    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
			"        if (l >= y || r <= x) {",
			"            return;",
			"        }",
			"        if (l >= x && r <= y) {",
			"            apply(p, v);",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        rangeApply(2 * p, l, m, x, y, v);",
			"        rangeApply(2 * p + 1, m, r, x, y, v);",
			"        pull(p);",
			"    }",
			"    void rangeApply(int l, int r, const Tag &v) {",
			"        return rangeApply(1, 0, n, l, r, v);",
			"    }",
			"    template<class F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        int res = findFirst(2 * p, l, m, x, y, pred);",
			"        if (res == -1) {",
			"            res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n, l, r, pred);",
			"    }",
			"    template<class F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l >= y || r <= x || !pred(info[p])) {",
			"            return -1;",
			"        }",
			"        if (r - l == 1) {",
			"            return l;",
			"        }",
			"        int m = (l + r) / 2;",
			"        push(p);",
			"        int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"        if (res == -1) {",
			"            res = findLast(2 * p, l, m, x, y, pred);",
			"        }",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n, l, r, pred);",
			"    }",
			"};",
			"",
			"struct Tag {",
			"    i64 a = 0, b = 0;",
			"    void apply(Tag t) {",
			"        a = std::min(a, b + t.a);",
			"        b += t.b;",
			"    }",
			"};",
			"",
			"int k;",
			"",
			"struct Info {",
			"    i64 x = 0;",
			"    void apply(Tag t) {",
			"        x += t.a;",
			"        if (x < 0) {",
			"            x = (x % k + k) % k;",
			"        }",
			"        x += t.b - t.a;",
			"    }",
			"};",
			"Info operator+(Info a, Info b) {",
			"    return {a.x + b.x};",
			"}"
		],
		"description": "LazySegmentTree"
	},
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"struct Info",
			"{",
			"    int a;",
			"    Info operator+(Info x) {",
			"        return Info(std::gcd(a, x.a));",
			"    }",
			"};",
			"",
			"struct sparse_table",
			"{",
			"    std::vector<std::vector<Info>> vt;",
			"    sparse_table(std::vector<Info> a) {",
			"        int n = a.size();",
			"        vt.assign(n, std::vector<Info>(30));",
			"        for (int i = 0;i < n;++i)",
			"            vt[i][0] = a[i];",
			"        for (int s = 1;s < 30;++s) {",
			"            for (int i = 0;i < n;++i) {",
			"                int j = i + (1 << s - 1);",
			"                if (j < n) {",
			"                    vt[i][s] = vt[i][s - 1] + vt[i + (1 << s - 1)][s - 1];",
			"                }",
			"                else vt[i][s] = vt[i][s - 1];",
			"            }",
			"        }",
			"    }",
			"    Info query(int l, int r) {//[l,r)",
			"        int len = r - l;",
			"        int x = std::__lg(len);",
			"        return vt[l][x] + vt[r - (1 << x)][x];",
			"    }",
			"};"
		],
		"description": "sparse_table"
	},
	"OnRMQ": {
		"prefix": "OnRMQ",
		"body": [
			"template<class T,",
			"    class Cmp = std::less<T>>",
			"struct RMQ {",
			"    const Cmp cmp = Cmp();",
			"    static constexpr unsigned B = 64;",
			"    using u64 = unsigned long long;",
			"    int n;",
			"    std::vector<std::vector<T>> a;",
			"    std::vector<T> pre, suf, ini;",
			"    std::vector<u64> stk;",
			"    RMQ() {}",
			"    RMQ(const std::vector<T> &v) {",
			"        init(v);",
			"    }",
			"    void init(const std::vector<T> &v) {",
			"        n = v.size();",
			"        pre = suf = ini = v;",
			"        stk.resize(n);",
			"        if (!n) {",
			"            return;",
			"        }",
			"        const int M = (n - 1) / B + 1;",
			"        const int lg = std::__lg(M);",
			"        a.assign(lg + 1, std::vector<T>(M));",
			"        for (int i = 0; i < M; i++) {",
			"            a[0][i] = v[i * B];",
			"            for (int j = 1; j < B && i * B + j < n; j++) {",
			"                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);",
			"            }",
			"        }",
			"        for (int i = 1; i < n; i++) {",
			"            if (i % B) {",
			"                pre[i] = std::min(pre[i], pre[i - 1], cmp);",
			"            }",
			"        }",
			"        for (int i = n - 2; i >= 0; i--) {",
			"            if (i % B != B - 1) {",
			"                suf[i] = std::min(suf[i], suf[i + 1], cmp);",
			"            }",
			"        }",
			"        for (int j = 0; j < lg; j++) {",
			"            for (int i = 0; i + (2 << j) <= M; i++) {",
			"                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);",
			"            }",
			"        }",
			"        for (int i = 0; i < M; i++) {",
			"            const int l = i * B;",
			"            const int r = std::min(1U * n, l + B);",
			"            u64 s = 0;",
			"            for (int j = l; j < r; j++) {",
			"                while (s && cmp(v[j], v[std::__lg(s) + l])) {",
			"                    s ^= 1ULL << std::__lg(s);",
			"                }",
			"                s |= 1ULL << (j - l);",
			"                stk[j] = s;",
			"            }",
			"        }",
			"    } ",
			"    T operator()(int l, int r) {",
			"        if (l / B != (r - 1) / B) {",
			"            T ans = std::min(suf[l], pre[r - 1], cmp);",
			"            l = l / B + 1;",
			"            r = r / B;",
			"            if (l < r) {",
			"                int k = std::__lg(r - l);",
			"                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);",
			"            }",
			"            return ans;",
			"        } else {",
			"            int x = B * (l / B);",
			"            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];",
			"        }",
			"    }",
			"};",
			""
		],
		"description": "OnRMQ"
	},
	"MidHeap": {
		"prefix": "MidHeap",
		"body": [
			"namespace Set {",
			"    const int kInf = 1e9 + 2077;",
			"    std::multiset<int> less, greater;",
			"    void init() {",
			"        less.clear(), greater.clear();",
			"        less.insert(-kInf), greater.insert(kInf);",
			"    }",
			"    void adjust() {",
			"        while (less.size() > greater.size() + 1) {",
			"            std::multiset<int>::iterator it = (--less.end());",
			"            greater.insert(*it);",
			"            less.erase(it);",
			"        }",
			"        while (greater.size() > less.size()) {",
			"            std::multiset<int>::iterator it = greater.begin();",
			"            less.insert(*it);",
			"            greater.erase(it);",
			"        }",
			"    }",
			"    void add(int val_) {",
			"        if (val_ <= *greater.begin()) less.insert(val_);",
			"        else greater.insert(val_);",
			"        adjust();",
			"    }",
			"    void del(int val_) {",
			"        std::multiset<int>::iterator it = less.lower_bound(val_);",
			"        if (it != less.end()) {",
			"            less.erase(it);",
			"        }",
			"        else {",
			"            it = greater.lower_bound(val_);",
			"            greater.erase(it);",
			"        }",
			"        adjust();",
			"    }",
			"    int get_middle() {",
			"        return *less.rbegin();",
			"    }",
			"}"
		],
		"description": "MidHeap"
	}
}