{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"get_diam": {
		"scope": "cpp",
		"prefix": "get_diam",
		"body": [
			"using a3 = std::array<i64, 3>;",
			"",
			"std::vector<pii> adj[MAXN];",
			"",
			"i64 cur;",
			"int pos;",
			"void dfs(int x, int p, i64 d) {",
			"    if (d > cur) {",
			"        cur = d;",
			"        pos = x;",
			"    }",
			"    for (auto [nxt, dis] : adj[x])if (nxt != p) {",
			"        dfs(nxt, x, d + dis);",
			"    }",
			"}",
			"",
			"a3 get_diam() {",
			"    cur = 0, pos = 1;",
			"    dfs(pos, 0, cur);",
			"    int u = pos;",
			"    cur = 0;",
			"    dfs(pos, 0, cur);",
			"    int v = pos;",
			"    return { u,v,cur };",
			"}"
		],
		"description": "get_diam"
	},
	"lca": {
		"prefix": "lca",
		"body": [
			"int depth[MAXN], lg[MAXN], p[MAXN][30];",
			"int lca(int x, int y) {",
			"    if (depth[x] < depth[y])swap(x, y);",
			"    while (depth[x] > depth[y])",
			"        x = p[x][lg[depth[x] - depth[y]] - 1];",
			"    if (x == y)return x;",
			"    for (int k = lg[depth[x]] - 1;k >= 0;--k)",
			"        if (p[x][k] != p[y][k])",
			"            x = p[x][k], y = p[y][k];",
			"    return p[x][0];",
			"}",
			"",
			"void dfs(int x, int par) {",
			"    p[x][0] = par;",
			"    depth[x] = depth[par] + 1;",
			"    for (int i = 1;i <= lg[depth[x]];++i)",
			"        p[x][i] = p[p[x][i - 1]][i - 1];",
			"",
			"    for (int nxt : adj[x])if (nxt != par)dfs(nxt, x);",
			"}",
			"",
			"void init() {",
			"    for (int i = 1;i <= n;++i)",
			"        lg[i] = lg[i >> 1] + 1;",
			"}",
			"",
			"int get_dis(int u, int v) {",
			"    int c = lca(u, v);",
			"    return depth[u] + depth[v] - depth[c] * 2;",
			"}"
		]
	},
	"hpd_tree": {
		"prefix": "hpd_tree",
		"body": [
			"struct HPD_tree",
			"{",
			"    int tree_size;",
			"    bool is_hpd_init = false;",
			"    std::vector<std::vector<std::pair<int, i64>>> adj;",
			"    std::vector<int> Fa, size, hson, top, rank, dfn, depth;",
			"    HPD_tree(int n = 0) {",
			"        tree_size = n;",
			"        adj.resize(tree_size + 1);",
			"    }",
			"    void add_edge(int u, int v, i64 w = 1) {",
			"        adj[u].push_back({ v,w });",
			"        adj[v].push_back({ u,w });",
			"    }",
			"    void HPD_init() {",
			"        is_hpd_init = true;",
			"        Fa.assign(tree_size + 1, 0);",
			"        size.assign(tree_size + 1, 0);",
			"        hson.assign(tree_size + 1, 0);",
			"        top.assign(tree_size + 1, 0);",
			"        rank.assign(tree_size + 1, 0);",
			"        dfn.assign(tree_size + 1, 0);",
			"        depth.assign(tree_size + 1, 0);",
			"        std::function<void(int, int, int)> dfs1 = [&](int u, int p, int d)->void {",
			"            hson[u] = 0;",
			"            size[hson[u]] = 0;",
			"            size[u] = 1;",
			"            depth[u] = d;",
			"            for (auto [v, w] : adj[u])if (v != p) {",
			"                dfs1(v, u, d + 1);",
			"                size[u] += size[v];",
			"                Fa[v] = u;",
			"                if (size[v] > size[hson[u]]) {",
			"                    hson[u] = v;",
			"                }",
			"            }",
			"            };",
			"        dfs1(1, 0, 0);",
			"        int tot = 0;",
			"        std::function<void(int, int, int)> dfs2 = [&](int u, int p, int t)->void {",
			"            top[u] = t;",
			"            dfn[u] = ++tot;",
			"            rank[tot] = u;",
			"            if (hson[u]) {",
			"                dfs2(hson[u], u, t);",
			"                for (auto [v, w] : adj[u])if (v != p && v != hson[u]) {",
			"                    dfs2(v, u, v);",
			"                }",
			"            }",
			"            };",
			"        dfs2(1, 0, 1);",
			"    }",
			"    int lca(int u, int v) {",
			"        if (!is_hpd_init)HPD_init();",
			"        while (top[u] != top[v]) {",
			"            if (depth[top[u]] > depth[top[v]])",
			"                u = Fa[top[u]];",
			"            else",
			"                v = Fa[top[v]];",
			"        }",
			"        return depth[u] > depth[v] ? v : u;",
			"    }",
			"    i64 dist(int u, int v) {",
			"        int w = lca(u, v);",
			"        return depth[u] - depth[w] + depth[v] - depth[w] + 1;",
			"    }",
			"    a3 get_diam() {",
			"        i64 cur; int pos;",
			"        std::function<void(int, int, i64)> dfs = [&](int u, int p, i64 d) {",
			"            if (d > cur) {",
			"                cur = d;",
			"                pos = u;",
			"            }",
			"            for (auto [v, dis] : adj[u])if (v != p) {",
			"                dfs(v, u, d + dis);",
			"            }",
			"            };",
			"        cur = 0, pos = 1;",
			"        dfs(pos, 0, cur);",
			"        int u = pos;",
			"        cur = 0;",
			"        dfs(pos, 0, cur);",
			"        int v = pos;",
			"        return { u,v,cur };",
			"    }",
			"};"
		],
		"description": "hpd_tree"
	},
	"scc": {
		"prefix": "scc",
		"body": [
			"struct SCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> stk;",
			"    std::vector<int> dfn, low, bel;",
			"    int cur, cnt;",
			"    ",
			"    SCC() {}",
			"    SCC(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"    }",
			"    ",
			"    void dfs(int x) {",
			"        dfn[x] = low[x] = cur++;",
			"        stk.push_back(x);",
			"        ",
			"        for (auto y : adj[x]) {",
			"            if (dfn[y] == -1) {",
			"                dfs(y);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (bel[y] == -1) {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[x] == low[x]) {",
			"            int y;",
			"            do {",
			"                y = stk.back();",
			"                bel[y] = cnt;",
			"                stk.pop_back();",
			"            } while (y != x);",
			"            cnt++;",
			"        }",
			"    }",
			"    ",
			"    std::vector<int> work() {",
			"        for (int i = 0; i < n; i++) {",
			"            if (dfn[i] == -1) {",
			"                dfs(i);",
			"            }",
			"        }",
			"        return bel;",
			"    }",
			"};",
			""
		],
		"description": "scc"
	},
	"ebcc": {
		"prefix": "ebcc",
		"body": [
			"std::set<std::pair<int, int>> E;",
			"",
			"struct EBCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> stk;",
			"    std::vector<int> dfn, low, bel;",
			"    int cur, cnt;",
			"    ",
			"    EBCC() {}",
			"    EBCC(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
			"    ",
			"    void dfs(int x, int p) {",
			"        dfn[x] = low[x] = cur++;",
			"        stk.push_back(x);",
			"        ",
			"        for (auto y : adj[x]) {",
			"            if (y == p) {",
			"                continue;",
			"            }",
			"            if (dfn[y] == -1) {",
			"                E.emplace(x, y);",
			"                dfs(y, x);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (bel[y] == -1 && dfn[y] < dfn[x]) {",
			"                E.emplace(x, y);",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[x] == low[x]) {",
			"            int y;",
			"            do {",
			"                y = stk.back();",
			"                bel[y] = cnt;",
			"                stk.pop_back();",
			"            } while (y != x);",
			"            cnt++;",
			"        }",
			"    }",
			"    ",
			"    std::vector<int> work() {",
			"        dfs(0, -1);",
			"        return bel;",
			"    }",
			"    ",
			"    struct Graph {",
			"        int n;",
			"        std::vector<std::pair<int, int>> edges;",
			"        std::vector<int> siz;",
			"        std::vector<int> cnte;",
			"    };",
			"    Graph compress() {",
			"        Graph g;",
			"        g.n = cnt;",
			"        g.siz.resize(cnt);",
			"        g.cnte.resize(cnt);",
			"        for (int i = 0; i < n; i++) {",
			"            g.siz[bel[i]]++;",
			"            for (auto j : adj[i]) {",
			"                if (bel[i] < bel[j]) {",
			"                    g.edges.emplace_back(bel[i], bel[j]);",
			"                } else if (i < j) {",
			"                    g.cnte[bel[i]]++;",
			"                }",
			"            }",
			"        }",
			"        return g;",
			"    }",
			"};"
		],
		"description": "ebcc"
	},
	"maxflow": {
		"prefix": "maxflow",
		"body": [
			"constexpr int inf = 1E9;",
			"template<class T>",
			"struct MaxFlow {",
			"    struct _Edge {",
			"        int to;",
			"        T cap;",
			"        _Edge(int to, T cap) : to(to), cap(cap) {}",
			"    };",
			"    ",
			"    int n;",
			"    std::vector<_Edge> e;",
			"    std::vector<std::vector<int>> g;",
			"    std::vector<int> cur, h;",
			"    ",
			"    MaxFlow() {}",
			"    MaxFlow(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        e.clear();",
			"        g.assign(n, {});",
			"        cur.resize(n);",
			"        h.resize(n);",
			"    }",
			"    ",
			"    bool bfs(int s, int t) {",
			"        h.assign(n, -1);",
			"        std::queue<int> que;",
			"        h[s] = 0;",
			"        que.push(s);",
			"        while (!que.empty()) {",
			"            const int u = que.front();",
			"            que.pop();",
			"            for (int i : g[u]) {",
			"                auto [v, c] = e[i];",
			"                if (c > 0 && h[v] == -1) {",
			"                    h[v] = h[u] + 1;",
			"                    if (v == t) {",
			"                        return true;",
			"                    }",
			"                    que.push(v);",
			"                }",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"    ",
			"    T dfs(int u, int t, T f) {",
			"        if (u == t) {",
			"            return f;",
			"        }",
			"        auto r = f;",
			"        for (int &i = cur[u]; i < int(g[u].size()); ++i) {",
			"            const int j = g[u][i];",
			"            auto [v, c] = e[j];",
			"            if (c > 0 && h[v] == h[u] + 1) {",
			"                auto a = dfs(v, t, std::min(r, c));",
			"                e[j].cap -= a;",
			"                e[j ^ 1].cap += a;",
			"                r -= a;",
			"                if (r == 0) {",
			"                    return f;",
			"                }",
			"            }",
			"        }",
			"        return f - r;",
			"    }",
			"    void addEdge(int u, int v, T c) {",
			"        g[u].push_back(e.size());",
			"        e.emplace_back(v, c);",
			"        g[v].push_back(e.size());",
			"        e.emplace_back(u, 0);",
			"    }",
			"    T flow(int s, int t) {",
			"        T ans = 0;",
			"        while (bfs(s, t)) {",
			"            cur.assign(n, 0);",
			"            ans += dfs(s, t, std::numeric_limits<T>::max());",
			"        }",
			"        return ans;",
			"    }",
			"    ",
			"    std::vector<bool> minCut() {",
			"        std::vector<bool> c(n);",
			"        for (int i = 0; i < n; i++) {",
			"            c[i] = (h[i] != -1);",
			"        }",
			"        return c;",
			"    }",
			"    ",
			"    struct Edge {",
			"        int from;",
			"        int to;",
			"        T cap;",
			"        T flow;",
			"    };",
			"    std::vector<Edge> edges() {",
			"        std::vector<Edge> a;",
			"        for (int i = 0; i < e.size(); i += 2) {",
			"            Edge x;",
			"            x.from = e[i + 1].to;",
			"            x.to = e[i].to;",
			"            x.cap = e[i].cap + e[i + 1].cap;",
			"            x.flow = e[i + 1].cap;",
			"            a.push_back(x);",
			"        }",
			"        return a;",
			"    }",
			"};"
		],
		"description": "maxflow"
	}
}