{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"sort": {
		"prefix": "sort",
		"body": [
			"ranges::sort(${a});"
		],
		"description": "sort"
	},
	"MultiTests": {
		"prefix": "MultiTests",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"using u128 = unsigned __int128;",
			"",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int t;std::cin >> t;",
			"    while (t--) {",
			"        solve();",
			"        std::cout << '\\n';",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "MultiTests"
	},
	"OneTest": {
		"prefix": "OneTest",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define ranges std::ranges",
			"#define views std::views",
			"",
			"using u32 = unsigned;",
			"using i64 = long long;",
			"using u64 = unsigned long long;",
			"using u128 = unsigned __int128;",
			"",
			"using a2 = std::array<int, 2>;",
			"using a3 = std::array<int, 3>;",
			"using a4 = std::array<int, 4>;",
			"",
			"const int N = 1e6;",
			"const int MAXN = 1e6 + 10;",
			"const int inf = 1e9;",
			"// const int mod = 1e9 + 7;",
			"const int mod = 998244353;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"signed main() {",
			"    std::ios::sync_with_stdio(false);",
			"    std::cin.tie(0), std::cout.tie(0);",
			"    int t = 1;",
			"    while (t--) {",
			"        solve();",
			"        std::cout << '\\n';",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "OneTest"
	},
	"all": {
		"scope": "c++,cpp",
		"prefix": "all",
		"body": [
			"${a}.begin(),${a}.end()"
		],
		"description": "for all."
	},
	"rall": {
		"scope": "c++,cpp",
		"prefix": "rall",
		"body": [
			"${a}.rbegin(),${a}.rend()"
		],
		"description": "for all reverse."
	},
	"memset": {
		"scope": "c++,cpp",
		"prefix": "mem",
		"body": [
			"memset(${x}, ${value:-1}, sizeof ${x});"
		],
		"description": "mem"
	},
	"rng": {
		"prefix": "rng",
		"body": [
			"std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
		],
		"description": "rng"
	},
	"DynModInt": {
		"prefix": "DynModInt",
		"body": [
			"template<u32 Id>",
			"struct DynModInt {",
			"public:",
			"    constexpr DynModInt() : x(0) {}",
			"    template<std::unsigned_integral T>",
			"    constexpr DynModInt(T x_) : x(x_% mod()) {}",
			"    template<std::signed_integral T>",
			"    constexpr DynModInt(T x_) {",
			"        int v = x_ % int(mod());",
			"        if (v < 0) {",
			"            v += mod();",
			"        }",
			"        x = v;",
			"    }",
			"",
			"    constexpr static void setMod(u32 m) {",
			"        bt = m;",
			"    }",
			"",
			"    static u32 mod() {",
			"        return bt.mod();",
			"    }",
			"",
			"    constexpr u32 val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr DynModInt operator-() const {",
			"        DynModInt res;",
			"        res.x = (x == 0 ? 0 : mod() - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr DynModInt inv() const {",
			"        auto v = invGcd(x, mod());",
			"        assert(v.first == 1);",
			"        return v.second;",
			"    }",
			"",
			"    constexpr DynModInt& operator*=(const DynModInt& rhs)& {",
			"        x = bt.mul(x, rhs.val());",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator+=(const DynModInt& rhs)& {",
			"        x += rhs.val();",
			"        if (x >= mod()) {",
			"            x -= mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator-=(const DynModInt& rhs)& {",
			"        x -= rhs.val();",
			"        if (x >= mod()) {",
			"            x += mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr DynModInt& operator/=(const DynModInt& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr DynModInt operator*(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator+(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator-(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr DynModInt operator/(DynModInt lhs, const DynModInt& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::istream& operator>>(std::istream& is, DynModInt& a) {",
			"        i64 i;",
			"        is >> i;",
			"        a = i;",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const DynModInt& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(const DynModInt& lhs, const DynModInt& rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr std::strong_ordering operator<=>(const DynModInt& lhs, const DynModInt& rhs) {",
			"        return lhs.val() <=> rhs.val();",
			"    }",
			"",
			"private:",
			"    u32 x;",
			"    static Barrett bt;",
			"};",
			"",
			"template<u32 Id>",
			"Barrett DynModInt<Id>::bt = 998244353;"
		],
		"description": "DynModInt"
	},
	"modInt": {
		"prefix": "modInt",
		"body": [
			"",
			"template<class T>",
			"constexpr T power(T a, u64 b, T res = 1) {",
			"    for (; b != 0; b /= 2, a *= a) {",
			"        if (b & 1) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"template<u32 P>",
			"constexpr u32 mulMod(u32 a, u32 b) {",
			"    return u64(a) * b % P;",
			"}",
			"",
			"template<u64 P>",
			"constexpr u64 mulMod(u64 a, u64 b) {",
			"    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;",
			"    res %= P;",
			"    return res;",
			"}",
			"",
			"constexpr i64 safeMod(i64 x, i64 m) {",
			"    x %= m;",
			"    if (x < 0) {",
			"        x += m;",
			"    }",
			"    return x;",
			"}",
			"",
			"constexpr std::pair<i64, i64> invGcd(i64 a, i64 b) {",
			"    a = safeMod(a, b);",
			"    if (a == 0) {",
			"        return { b, 0 };",
			"    }",
			"",
			"    i64 s = b, t = a;",
			"    i64 m0 = 0, m1 = 1;",
			"",
			"    while (t) {",
			"        i64 u = s / t;",
			"        s -= t * u;",
			"        m0 -= m1 * u;",
			"",
			"        std::swap(s, t);",
			"        std::swap(m0, m1);",
			"    }",
			"",
			"    if (m0 < 0) {",
			"        m0 += b / s;",
			"    }",
			"",
			"    return { s, m0 };",
			"}",
			"",
			"template<std::unsigned_integral U, U P>",
			"struct ModIntBase {",
			"public:",
			"    constexpr ModIntBase() : x(0) {}",
			"    template<std::unsigned_integral T>",
			"    constexpr ModIntBase(T x_) : x(x_% mod()) {}",
			"    template<std::signed_integral T>",
			"    constexpr ModIntBase(T x_) {",
			"        using S = std::make_signed_t<U>;",
			"        S v = x_ % S(mod());",
			"        if (v < 0) {",
			"            v += mod();",
			"        }",
			"        x = v;",
			"    }",
			"",
			"    constexpr static U mod() {",
			"        return P;",
			"    }",
			"",
			"    constexpr U val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr ModIntBase operator-() const {",
			"        ModIntBase res;",
			"        res.x = (x == 0 ? 0 : mod() - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr ModIntBase inv() const {",
			"        return power(*this, mod() - 2);",
			"    }",
			"",
			"    constexpr ModIntBase& operator*=(const ModIntBase& rhs)& {",
			"        x = mulMod<mod()>(x, rhs.val());",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator+=(const ModIntBase& rhs)& {",
			"        x += rhs.val();",
			"        if (x >= mod()) {",
			"            x -= mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator-=(const ModIntBase& rhs)& {",
			"        x -= rhs.val();",
			"        if (x >= mod()) {",
			"            x += mod();",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr ModIntBase& operator/=(const ModIntBase& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::istream& operator>>(std::istream& is, ModIntBase& a) {",
			"        i64 i;",
			"        is >> i;",
			"        a = i;",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const ModIntBase& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(const ModIntBase& lhs, const ModIntBase& rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr std::strong_ordering operator<=>(const ModIntBase& lhs, const ModIntBase& rhs) {",
			"        return lhs.val() <=> rhs.val();",
			"    }",
			"",
			"private:",
			"    U x;",
			"};",
			"",
			"template<u32 P>",
			"using ModInt = ModIntBase<u32, P>;",
			"template<u64 P>",
			"using ModInt64 = ModIntBase<u64, P>;",
			"",
			"struct Barrett {",
			"public:",
			"    Barrett(u32 m_) : m(m_), im((u64)(-1) / m_ + 1) {}",
			"",
			"    constexpr u32 mod() const {",
			"        return m;",
			"    }",
			"",
			"    constexpr u32 mul(u32 a, u32 b) const {",
			"        u64 z = a;",
			"        z *= b;",
			"",
			"        u64 x = u64((u128(z) * im) >> 64);",
			"",
			"        u32 v = u32(z - x * m);",
			"        if (m <= v) {",
			"            v += m;",
			"        }",
			"        return v;",
			"    }",
			"",
			"private:",
			"    u32 m;",
			"    u64 im;",
			"};",
			"",
			"using Z = ModInt<mod>;"
		],
		"description": "modInt"
	},
	"ModUint": {
		"prefix": "ModUint",
		"body": [
			"template<typename T>",
			"constexpr T power(T a, u64 b) {",
			"    T res{ 1 };",
			"    for (; b != 0; b /= 2, a *= a) {",
			"        if (b % 2 == 1) {",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"template<u32 P>",
			"constexpr u32 mulMod(u32 a, u32 b) {",
			"    return 1ULL * a * b % P;",
			"}",
			"",
			"template<u64 P>",
			"constexpr u64 mulMod(u64 a, u64 b) {",
			"    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;",
			"    res %= P;",
			"    return res;",
			"}",
			"",
			"template<typename U, U P>",
			"    requires std::unsigned_integral<U>",
			"struct ModIntBase {",
			"public:",
			"    constexpr ModIntBase() : x{ 0 } {}",
			"",
			"    template<typename T>",
			"        requires std::integral<T>",
			"    constexpr ModIntBase(T x_) : x{ norm(x_ % T {P}) } {}",
			"",
			"    constexpr static U norm(U x) {",
			"        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {",
			"            x += P;",
			"        }",
			"        if (x >= P) {",
			"            x -= P;",
			"        }",
			"        return x;",
			"    }",
			"",
			"    constexpr U val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr ModIntBase operator-() const {",
			"        ModIntBase res;",
			"        res.x = norm(P - x);",
			"        return res;",
			"    }",
			"",
			"    constexpr ModIntBase inv() const {",
			"        return power(*this, P - 2);",
			"    }",
			"",
			"    constexpr ModIntBase& operator*=(const ModIntBase& rhs)& {",
			"        x = mulMod<P>(x, rhs.val());",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator+=(const ModIntBase& rhs)& {",
			"        x = norm(x + rhs.x);",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator-=(const ModIntBase& rhs)& {",
			"        x = norm(x - rhs.x);",
			"        return *this;",
			"    }",
			"",
			"    constexpr ModIntBase& operator/=(const ModIntBase& rhs)& {",
			"        return *this *= rhs.inv();",
			"    }",
			"",
			"    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs *= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs += rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs -= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase& rhs) {",
			"        lhs /= rhs;",
			"        return lhs;",
			"    }",
			"",
			"    friend constexpr std::ostream& operator<<(std::ostream& os, const ModIntBase& a) {",
			"        return os << a.val();",
			"    }",
			"",
			"    friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() == rhs.val();",
			"    }",
			"",
			"    friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() != rhs.val();",
			"    }",
			"",
			"    friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {",
			"        return lhs.val() < rhs.val();",
			"    }",
			"",
			"private:",
			"    U x;",
			"};",
			"",
			"template<u32 P>",
			"using ModInt = ModIntBase<u32, P>;",
			"",
			"template<u64 P>",
			"using ModInt64 = ModIntBase<u64, P>;",
			"",
			"constexpr u32 P = 998244353;",
			"using Z = ModInt<P>;"
		],
		"description": "Mi64"
	},
	"i128": {
		"prefix": "i128",
		"body": [
			"using i128 = __int128;",
			"",
			"std::istream& operator>>(std::istream& is, i128& n) {",
			"    std::string s;is >> s;",
			"    n = 0;",
			"    for (char i : s) n = n * 10 + i - '0';",
			"    return is;",
			"}",
			"std::ostream& operator<<(std::ostream& os, i128 n) {",
			"    if (n == 0) {",
			"        return os << 0;",
			"    }",
			"    std::string s;",
			"    while (n) {",
			"        s += '0' + n % 10;",
			"        n /= 10;",
			"    }",
			"    std::reverse(s.begin(), s.end());",
			"    return os << s;",
			"}"
		],
		"description": "i128"
	},
	"division": {
		"prefix": "division",
		"body": [
			"i64 ceilDiv(i64 n, i64 m) {",
			"    if (n >= 0) {",
			"        return (n + m - 1) / m;",
			"    } else {",
			"        return n / m;",
			"    }",
			"}",
			" ",
			"i64 floorDiv(i64 n, i64 m) {",
			"    if (n >= 0) {",
			"        return n / m;",
			"    } else {",
			"        return (n - m + 1) / m;",
			"    }",
			"}"
		],
		"description": "c_f_division"
	},
	"chmax": {
		"prefix": "chmax",
		"body": [
			"template<class T>",
			"void chmax(T &a, T b) {",
			"    if (a < b) {",
			"        a = b;",
			"    }",
			"}"
		],
		"description": "chmax"
	}
}