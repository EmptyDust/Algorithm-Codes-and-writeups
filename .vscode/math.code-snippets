{
	//将您的全局片段放在此处。每个代码段都定义在一个代码段名称下，并具有范围、前缀、正文和
	//描述在范围字段中添加代码段适用的语言的逗号分隔ID。如果范围
	//如果为空或被省略，则该片段将应用于所有语言。前缀是什么
	//用于触发摘录，并且正文将被展开和插入。可能的变量包括：
	//$1，$2用于制表位，$0用于最后的光标位置，${1:label}，${2:other}用于占位符。
	//具有相同id的占位符是连接的。
	"dichotomy": {
		"scope": "c++,cpp",
		"prefix": "dichotomy",
		"body": [
			"auto l = ${l}, r = ${r};",
			"auto check = [&](auto x)->bool {",
			"    $0",
			"    };",
			"while (l < r) {",
			"    auto mid = l + r >> 1;",
			"    if (check(mid))r = mid;",
			"    else l = mid + 1;",
			"}"
		],
		"description": "dichotomy."
	},
	"lg2": {
		"scope": "c++,cpp",
		"prefix": "lg2",
		"body": [
			"auto lg2(auto x) { return x ? std::__lg(x) : -1; }",
		],
		"description": "log2."
	},
	"exgcd": {
		"scope": "c++,cpp",
		"prefix": "exgcd",
		"body": [
			"void exGCD(int a, int b, int& x, int& y) {",
			"    if (!b) x = 1, y = 0;",
			"    else exGCD(b, a % b, y, x), y -= a / b * x;",
			"}"
		],
		"description": "exgcd"
	},
	"inv": {
		"scope": "c++,cpp",
		"prefix": "inv",
		"body": [
			"i64 qpow(i64 x, i64 p) {",
			"    i64 ret = 1;",
			"    while (p) {",
			"        if (p & 1)ret = ret * x % mod;",
			"        p >>= 1;",
			"        x = x * x % mod;",
			"    }",
			"    return ret;",
			"}",
			"",
			"#define inv(x) qpow(x,mod-2)"
		],
		"description": "inv"
	},
	"qpow": {
		"scope": "c++,cpp",
		"prefix": "qpow",
		"body": [
			"i64 qpow(i64 x, i64 p) {",
			"    i64 ret = 1;",
			"    while (p) {",
			"        if (p & 1)ret = ret * x % mod;",
			"        p >>= 1;",
			"        x = x * x % mod;",
			"    }",
			"    return ret;",
			"}",
		],
		"description": "qpow"
	},
	"comb": {
		"prefix": "comb",
		"body": [
			"struct Comb {",
			"    int n;",
			"    std::vector<Z> _fac;",
			"    std::vector<Z> _invfac;",
			"    std::vector<Z> _inv;",
			"",
			"    Comb() : n{ 0 }, _fac{ 1 }, _invfac{ 1 }, _inv{ 0 } {}",
			"    Comb(int n) : Comb() {",
			"        init(n);",
			"    }",
			"",
			"    void init(int m) {",
			"        if (m <= n) return;",
			"        _fac.resize(m + 1);",
			"        _invfac.resize(m + 1);",
			"        _inv.resize(m + 1);",
			"",
			"        for (int i = n + 1; i <= m; i++) {",
			"            _fac[i] = _fac[i - 1] * i;",
			"        }",
			"        _invfac[m] = _fac[m].inv();",
			"        for (int i = m; i > n; i--) {",
			"            _invfac[i - 1] = _invfac[i] * i;",
			"            _inv[i] = _invfac[i] * _fac[i - 1];",
			"        }",
			"        n = m;",
			"    }",
			"",
			"    Z fac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _fac[m];",
			"    }",
			"    Z invfac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _invfac[m];",
			"    }",
			"    Z inv(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _inv[m];",
			"    }",
			"    Z binom(int n, int m) {",
			"        if (n < m || m < 0) return 0;",
			"        return fac(n) * invfac(m) * invfac(n - m);",
			"    }",
			"} comb;"
		],
		"description": "comb"
	},
	"lg": {
		"scope": "c++,cpp",
		"prefix": "lg",
		"body": [
			"for (int i = 1;i <= n;++i)",
			"lg[i] = lg[i >> 1] + 1;"
		]
	},
	"BSGS": {
		"scope": "cpp,c++",
		"prefix": "BSGS",
		"body": [
			"i64 BSGS(i64 a, i64 b, i64 m, i64 k = 1) {",
			"    static std::unordered_map<i64, i64> hs;",
			"    hs.clear();",
			"    i64 cur = 1, t = sqrt(m) + 1;",
			"    for (int B = 1; B <= t; ++B) {",
			"        (cur *= a) %= m;",
			"        hs[b * cur % m] = B; // 哈希表中存B的值",
			"    }",
			"    i64 now = cur * k % m;",
			"    for (int A = 1; A <= t; ++A) {",
			"        auto it = hs.find(now);",
			"        if (it != hs.end()) return A * t - it->second;",
			"        (now *= cur) %= m;",
			"    }",
			"    return -inf; // 这里因为要多次加1,要返回更小的负数",
			"}"
		]
	},
	"get_primes": {
		"prefix": "get_primes",
		"body": [
			"std::vector<int> minp, primes;",
			"",
			"void sieve(int n) {",
			"    minp.assign(n + 1, 0);",
			"    primes.clear();",
			"    ",
			"    for (int i = 2; i <= n; i++) {",
			"        if (minp[i] == 0) {",
			"            minp[i] = i;",
			"            primes.push_back(i);",
			"        }",
			"        ",
			"        for (auto p : primes) {",
			"            if (i * p > n) {",
			"                break;",
			"            }",
			"            minp[i * p] = p;",
			"            if (p == minp[i]) {",
			"                break;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "get_primes"
	},
	"ntt": {
		"prefix": "ntt",
		"body": [
			"namespace ntt {",
			"",
			"    const long long mod = 998244353;",
			"    const long long G = 3;",
			"    const long long Gi = 332748118; // G 在模 p 意义下的逆元",
			"",
			"    class P {",
			"    public:",
			"        long long a{};",
			"",
			"        P() = default;",
			"",
			"        [[nodiscard]] long long get() const {",
			"            return a;",
			"        }",
			"",
			"        explicit P(long long p) {",
			"            a = p % mod;",
			"            if (a < 0) {",
			"                a += mod;",
			"            }",
			"        };",
			"",
			"        P operator+(const P& rhs) const {",
			"            return P{ a + rhs.a };",
			"        }",
			"",
			"        P operator-(const P& rhs) const {",
			"            return P{ a - rhs.a };",
			"        }",
			"",
			"        P operator*(const P& rhs) const {",
			"            return P{ a * rhs.a };",
			"        }",
			"",
			"        [[nodiscard]] P pow(long long n) const {",
			"            P bas = P(a);",
			"            P res = P(1);",
			"            while (n > 0) {",
			"                if (n % 2 == 1) {",
			"                    res = res * bas;",
			"                }",
			"                bas = bas * bas;",
			"                n /= 2;",
			"            }",
			"            return res;",
			"        }",
			"",
			"        [[nodiscard]] P inverse() const {",
			"            return pow(mod - 2);",
			"        }",
			"    };",
			"",
			"    class NTTMultiplier {",
			"    public:",
			"        vector<int> input1;",
			"        vector<int> input2;",
			"        vector<int> bitInv;//位逆置换使用",
			"        int size{};",
			"",
			"        NTTMultiplier(const vector<int>& v1, const vector<int>& v2) {",
			"            input1 = v1;",
			"            input2 = v2;",
			"            size = (int)(input1.size() + input2.size() - 1);",
			"            int n = 1;",
			"            while (n < size) {",
			"                n <<= 1;",
			"            }",
			"            size = n;",
			"            input1.resize(size);",
			"            input2.resize(size);",
			"            bitInv.resize(size);",
			"            initBitInv();//位逆置换使用",
			"        }",
			"",
			"        void initBitInv() {",
			"            bitInv[0] = 0;",
			"            int log2n = (int)log2(size);",
			"            for (int i = 1; i < size; i++) {",
			"                int pre = (i & 1) << (log2n - 1);//第1位(奇数为1,偶数为0);",
			"                int suf = bitInv[i >> 1] >> 1;   //第2到第n位(这是的递推公式);",
			"                bitInv[i] = pre | suf;",
			"            }",
			"        }",
			"",
			"        vector<int> multiply() {",
			"            // 将输入转换为模数形式",
			"            vector<P> nttInput1(input1.begin(), input1.end());",
			"            vector<P> nttInput2(input2.begin(), input2.end());",
			"",
			"            // 执行快速傅里叶变换",
			"            fastNTT(nttInput1, false);",
			"            fastNTT(nttInput2, false);",
			"            // 对应位置相乘",
			"            for (int i = 0; i < size; i++) {",
			"                nttInput1[i] = nttInput1[i] * nttInput2[i];",
			"            }",
			"            // 执行反向快速傅里叶变换",
			"            fastNTT(nttInput1, true);",
			"            P invSize = P(size).inverse();",
			"            for (int i = 0; i < size; i++) {",
			"                nttInput1[i] = nttInput1[i] * invSize;",
			"            }",
			"",
			"            // 取实部并取整",
			"            vector<int> result(size);",
			"            for (int i = 0; i < size; i++) {",
			"                result[i] = (int)nttInput1[i].get();",
			"            }",
			"",
			"            input1.clear();",
			"            input2.clear();",
			"            size = 0;",
			"",
			"            return result;",
			"        }",
			"",
			"",
			"        void bitRev(vector<P>& arr) {",
			"            for (int i = 1; i < arr.size(); i++) {",
			"                if (i < bitInv[i]) {",
			"                    swap(arr[i], arr[bitInv[i]]);        //交换",
			"                }",
			"            }",
			"        }",
			"",
			"",
			"        void fastNTT(vector<P>& data, bool inverse) {",
			"            int n = (int)data.size();",
			"            bitRev(data);",
			"            P bas = inverse ? P(Gi) : P(G);",
			"            for (int len = 2; len <= n; len *= 2) {",
			"                long long angle = (long long)(mod - 1) / len;",
			"                P wn = bas.pow(angle);",
			"                for (int i = 0; i < n; i += len) {",
			"                    P w(1);",
			"                    for (int j = i; j < i + len / 2; j++) {",
			"                        P evenVal = data[j];",
			"                        P oddVal = data[j + len / 2] * w;",
			"                        data[j] = evenVal + oddVal;",
			"                        data[j + len / 2] = evenVal - oddVal;",
			"                        w = w * wn;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        void ntt(vector<P>& data, bool inverse) { // NOLINT(misc-no-recursion)",
			"            int n = (int)data.size();",
			"            if (n == 1) {",
			"                return;",
			"            }",
			"            vector<P> even(n / 2);",
			"            vector<P> odd(n / 2);",
			"            // 分离奇偶项",
			"            for (int i = 0; i < n / 2; i++) {",
			"                even[i] = data[2 * i];",
			"                odd[i] = data[2 * i + 1];",
			"            }",
			"            // 递归进行快速傅里叶变换",
			"            ntt(even, inverse);",
			"            ntt(odd, inverse);",
			"",
			"            P bas = inverse ? P(Gi) : P(G);",
			"            long long angle = (long long)(mod - 1) / n; // NOLINT(cppcoreguidelines-narrowing-conversions)",
			"            P w(1);",
			"            P wn = bas.pow(angle);",
			"            // 合并结果",
			"            for (int i = 0; i < n / 2; i++) {",
			"                P evenVal = even[i];",
			"                P oddVal = odd[i] * w;",
			"                data[i] = evenVal + oddVal;",
			"                data[i + n / 2] = evenVal - oddVal;",
			"                w = w * wn;",
			"            }",
			"        }",
			"    };",
			"}"
		],
		"description": "ntt"
	},
	"combdp": {
		"prefix": "combdp",
		"body": [
			"Mi64 comb[MAXN][MAXN];",
			"void init() {",
			"    for (int i = 0;i <= N;++i) {",
			"        comb[i][0] = 1;",
			"        for (int j = 1;j <= i;++j) {",
			"            comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];",
			"        }",
			"    }",
			"}"
		],
		"description": "combdp"
	},
	"Fact": {
		"prefix": "Fact",
		"body": [
			"struct Comb {",
			"    int n;",
			"    std::vector<Z> _fac;",
			"    std::vector<Z> _invfac;",
			"    std::vector<Z> _inv;",
			"",
			"    Comb() : n{ 0 }, _fac{ 1 }, _invfac{ 1 }, _inv{ 0 } {}",
			"    Comb(int n) : Comb() {",
			"        init(n);",
			"    }",
			"",
			"    void init(int m) {",
			"        if (m <= n) return;",
			"        _fac.resize(m + 1);",
			"        _invfac.resize(m + 1);",
			"        _inv.resize(m + 1);",
			"",
			"        for (int i = n + 1; i <= m; i++) {",
			"            _fac[i] = _fac[i - 1] * i;",
			"        }",
			"        _invfac[m] = _fac[m].inv();",
			"        for (int i = m; i > n; i--) {",
			"            _invfac[i - 1] = _invfac[i] * i;",
			"            _inv[i] = _invfac[i] * _fac[i - 1];",
			"        }",
			"        n = m;",
			"    }",
			"",
			"    Z fac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _fac[m];",
			"    }",
			"    Z invfac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _invfac[m];",
			"    }",
			"    Z inv(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _inv[m];",
			"    }",
			"    Z binom(int n, int m) {",
			"        if (n < m || m < 0) return 0;",
			"        return fac(n) * invfac(m) * invfac(n - m);",
			"    }",
			"} comb;"
		],
		"description": "Fact"
	},
	"Frac": {
		"prefix": "Frac",
		"body": [
			"template<class T>",
			"struct Frac {",
			"    T num;",
			"    T den;",
			"    Frac(T num_, T den_) : num(num_), den(den_) {",
			"        if (den < 0) {",
			"            den = -den;",
			"            num = -num;",
			"        }",
			"    }",
			"    Frac() : Frac(0, 1) {}",
			"    Frac(T num_) : Frac(num_, 1) {}",
			"    explicit operator double() const {",
			"        return 1. * num / den;",
			"    }",
			"    Frac& operator+=(const Frac& rhs) {",
			"        num = num * rhs.den + rhs.num * den;",
			"        den *= rhs.den;",
			"        return *this;",
			"    }",
			"    Frac& operator-=(const Frac& rhs) {",
			"        num = num * rhs.den - rhs.num * den;",
			"        den *= rhs.den;",
			"        return *this;",
			"    }",
			"    Frac& operator*=(const Frac& rhs) {",
			"        num *= rhs.num;",
			"        den *= rhs.den;",
			"        return *this;",
			"    }",
			"    Frac& operator/=(const Frac& rhs) {",
			"        num *= rhs.den;",
			"        den *= rhs.num;",
			"        if (den < 0) {",
			"            num = -num;",
			"            den = -den;",
			"        }",
			"        return *this;",
			"    }",
			"    friend Frac operator+(Frac lhs, const Frac& rhs) {",
			"        return lhs += rhs;",
			"    }",
			"    friend Frac operator-(Frac lhs, const Frac& rhs) {",
			"        return lhs -= rhs;",
			"    }",
			"    friend Frac operator*(Frac lhs, const Frac& rhs) {",
			"        return lhs *= rhs;",
			"    }",
			"    friend Frac operator/(Frac lhs, const Frac& rhs) {",
			"        return lhs /= rhs;",
			"    }",
			"    friend Frac operator-(const Frac& a) {",
			"        return Frac(-a.num, a.den);",
			"    }",
			"    friend bool operator==(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den == rhs.num * lhs.den;",
			"    }",
			"    friend bool operator!=(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den != rhs.num * lhs.den;",
			"    }",
			"    friend bool operator<(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den < rhs.num * lhs.den;",
			"    }",
			"    friend bool operator>(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den > rhs.num * lhs.den;",
			"    }",
			"    friend bool operator<=(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den <= rhs.num * lhs.den;",
			"    }",
			"    friend bool operator>=(const Frac& lhs, const Frac& rhs) {",
			"        return lhs.num * rhs.den >= rhs.num * lhs.den;",
			"    }",
			"    friend std::ostream& operator<<(std::ostream& os, Frac x) {",
			"        T g = std::gcd(x.num, x.den);",
			"        if (x.den == g) {",
			"            return os << x.num / g;",
			"        }",
			"        else {",
			"            return os << x.num / g << \"/\" << x.den / g;",
			"        }",
			"    }",
			"};"
		],
		"description": "Frac"
	},
	"Miller-Rabin & Pollard-Rho": {
		"prefix": "Miller-Rabin & Pollard-Rho",
		"body": [
			"i64 mul(i64 a, i64 b, i64 m) {",
			"    return static_cast<__int128>(a) * b % m;",
			"}",
			"i64 power(i64 a, i64 b, i64 m) {",
			"    i64 res = 1 % m;",
			"    for (; b; b >>= 1, a = mul(a, a, m))",
			"        if (b & 1)",
			"            res = mul(res, a, m);",
			"    return res;",
			"}",
			"bool isprime(i64 n) {",
			"    if (n < 2)",
			"        return false;",
			"    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};",
			"    int s = __builtin_ctzll(n - 1);",
			"    i64 d = (n - 1) >> s;",
			"    for (auto a : A) {",
			"        if (a == n)",
			"            return true;",
			"        i64 x = power(a, d, n);",
			"        if (x == 1 || x == n - 1)",
			"            continue;",
			"        bool ok = false;",
			"        for (int i = 0; i < s - 1; ++i) {",
			"            x = mul(x, x, n);",
			"            if (x == n - 1) {",
			"                ok = true;",
			"                break;",
			"            }",
			"        }",
			"        if (!ok)",
			"            return false;",
			"    }",
			"    return true;",
			"}",
			"std::vector<i64> factorize(i64 n) {",
			"    std::vector<i64> p;",
			"    std::function<void(i64)> f = [&](i64 n) {",
			"        if (n <= 10000) {",
			"            for (int i = 2; i * i <= n; ++i)",
			"                for (; n % i == 0; n /= i)",
			"                    p.push_back(i);",
			"            if (n > 1)",
			"                p.push_back(n);",
			"            return;",
			"        }",
			"        if (isprime(n)) {",
			"            p.push_back(n);",
			"            return;",
			"        }",
			"        auto g = [&](i64 x) {",
			"            return (mul(x, x, n) + 1) % n;",
			"        };",
			"        i64 x0 = 2;",
			"        while (true) {",
			"            i64 x = x0;",
			"            i64 y = x0;",
			"            i64 d = 1;",
			"            i64 power = 1, lam = 0;",
			"            i64 v = 1;",
			"            while (d == 1) {",
			"                y = g(y);",
			"                ++lam;",
			"                v = mul(v, std::abs(x - y), n);",
			"                if (lam % 127 == 0) {",
			"                    d = std::gcd(v, n);",
			"                    v = 1;",
			"                }",
			"                if (power == lam) {",
			"                    x = y;",
			"                    power *= 2;",
			"                    lam = 0;",
			"                    d = std::gcd(v, n);",
			"                    v = 1;",
			"                }",
			"            }",
			"            if (d != n) {",
			"                f(d);",
			"                f(n / d);",
			"                return;",
			"            }",
			"            ++x0;",
			"        }",
			"    };",
			"    f(n);",
			"    std::sort(p.begin(), p.end());",
			"    return p;",
			"}"
		],
		"description": "Miller-Rabin & Pollard-Rho"
	},
	"get_linear_basis": {
		"prefix": "get_linear_basis",
		"body": [
			"std::vector<i64> get_linear_basis(std::vector<i64>& nums, int N = 63) {",
			"    std::vector<i64> p(N + 1);",
			"    auto insert = [&](i64 x) {",
			"        for (int s = N;s >= 0;--s)if (x >> s & 1) {",
			"            if (!p[s]) {",
			"                p[s] = x;",
			"                break;",
			"            }",
			"            x ^= p[s];",
			"        }",
			"        };",
			"    for (auto& x : nums) insert(x);",
			"    return p;",
			"}"
		],
		"description": "get_linear_basis"
	},
	"exCRT": {
		"prefix": "exCRT",
		"body": [
			"template<typename T>",
			"struct TWOCRT {//中国剩余定理&扩展中国剩余定理",
			"    std::vector<T> m, r;",
			"    TWOCRT() {};",
			"    TWOCRT(T n) {",
			"        m.resize(n + 1);",
			"        r.resize(n + 1);",
			"    };",
			"    TWOCRT(std::vector<T> _m, std::vector<T> _r) {",
			"        m = _m;",
			"        r = _r;",
			"    }",
			"    T exgcd(T a, T b, __int128& x, __int128& y) {",
			"        if (b == 0) {",
			"            x = 1, y = 0;",
			"            return a;",
			"        }",
			"        T gcd = exgcd(b, a % b, y, x);",
			"        y -= (a / b) * x;",
			"        return gcd;",
			"    }",
			"    T CRT() {",
			"        T M = 1, ans = 0;",
			"        int n = m.size() - 1;",
			"        for (int i = 1; i <= n; i++)M *= m[i];",
			"        for (int i = 1; i <= n; i++) {",
			"            T c = M / m[i], x, y;",
			"            exgcd(c, m[i], x, y);",
			"            ans = (ans + r[i] * c * x % M) % M;",
			"        }",
			"        return (ans % M + M) % M;",
			"    }",
			"",
			"    T EXCRT() { //有x=r1(mod m1),x=r2(mod m2)",
			"        i128 m1, m2, r1, r2, p, q;                //转化为x=m1*p+r1=m2*q+r2  (1)",
			"        m1 = m[1], r1 = r[1];                   //m1*p-m2*q=r2-r1",
			"        int n = m.size() - 1;",
			"        for (int i = 2; i <= n; i++) {",
			"            m2 = m[i], r2 = r[i];",
			"            i128 d = exgcd(m1, m2, p, q);",
			"            if ((r2 - r1) % d) { return -1; }      //由裴蜀定理-->> 当gcd(m1,m2)|(r2-r1)时 有解",
			"            p = p * (r2 - r1) / d;//特解            //由扩欧算法得 特解p=p*(r2-r1)/gcd,q=q*(r2-r1)/gcd",
			"            p = (p % (m2 / d) + m2 / d) % (m2 / d);//p可能是负数，为了方便要使p变成正数,通解--》P=p+m2/gcd*k,Q=q-m1/gcd*k",
			"            r1 = m1 * p + r1;                     //x=m1*P+r1=(m1*m2)/gcd*k+m1*p1+r1,与（1）比对",
			"            m1 = m1 * m2 / d;                      //得r=m1*p+r1,m=lcm(m1,m2)",
			"        }",
			"        return (r1 % m1 + m1) % m1;",
			"    }",
			"};"
		],
		"description": "exCRT"
	},
	"xorn": {
		"prefix": "xorn",
		"body": [
			"i64 xorn(i64 n) {//from 0 to n - 1",
			"    if (n % 4 == 0) {",
			"        return 0;",
			"    } else if (n % 4 == 1) {",
			"        return n - 1;",
			"    } else if (n % 4 == 2) {",
			"        return 1;",
			"    } else {",
			"        return n;",
			"    }",
			"}"
		],
		"description": "xorn"
	}
}